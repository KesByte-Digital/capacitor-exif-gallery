{"version":3,"file":"FilterValidator.js","sourceRoot":"","sources":["../../src/FilterValidator.ts"],"names":[],"mappings":"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","sourcesContent":["import { PolylineDecoder } from './PolylineDecoder';\nimport type { FilterConfig, LatLng, LocationFilter, TimeRangeFilter } from './definitions';\nimport { FilterError } from './errors';\n\n/**\n * Validation utilities for filter parameters.\n *\n * Ensures filter configurations are valid before passing to native layers.\n *\n * @internal\n */\nexport class FilterValidator {\n  /**\n   * Validate that an object is a valid LatLng coordinate.\n   *\n   * Valid coordinates must have:\n   * - lat: number between -90 and 90\n   * - lng: number between -180 and 180\n   *\n   * @param obj - Object to validate\n   * @returns True if valid LatLng\n   *\n   * @example\n   * ```typescript\n   * isValidLatLng({ lat: 48.8566, lng: 2.3522 }); // true\n   * isValidLatLng({ lat: 200, lng: 0 }); // false (lat out of range)\n   * isValidLatLng({ lat: 0 }); // false (missing lng)\n   * ```\n   */\n  public static isValidLatLng(obj: any): obj is LatLng {\n    return (\n      obj !== null &&\n      obj !== undefined &&\n      typeof obj === 'object' &&\n      typeof obj.lat === 'number' &&\n      typeof obj.lng === 'number' &&\n      !isNaN(obj.lat) &&\n      !isNaN(obj.lng) &&\n      obj.lat >= -90 &&\n      obj.lat <= 90 &&\n      obj.lng >= -180 &&\n      obj.lng <= 180\n    );\n  }\n\n  /**\n   * Validate location filter configuration.\n   *\n   * Valid location filter must have:\n   * - Either polyline OR coordinates array (not both)\n   * - polyline/coordinates must be non-empty array of valid LatLng\n   * - radius must be > 0 if provided\n   *\n   * ⚠️ **MUTATION WARNING:** If polyline is provided as an encoded string,\n   * it will be decoded and replaced with a LatLng[] array in-place.\n   * This is an optimization to prevent double-decoding. If you need to\n   * preserve the original filter object, pass a deep copy.\n   *\n   * @mutates locationFilter.polyline - Replaces encoded string with decoded LatLng[]\n   * @param locationFilter - Location filter to validate\n   * @throws {Error} If validation fails\n   *\n   * @example\n   * ```typescript\n   * // Valid - coordinate array\n   * validateLocationFilter({\n   *   coordinates: [{ lat: 48.8566, lng: 2.3522 }],\n   *   radius: 500\n   * });\n   *\n   * // Valid - encoded polyline (will be decoded in-place)\n   * const filter = { polyline: \"_p~iF~ps|U_ulLnnqC\", radius: 1000 };\n   * validateLocationFilter(filter);\n   * // Note: filter.polyline is now LatLng[] (not string)\n   *\n   * // Invalid: empty coordinates array\n   * validateLocationFilter({ coordinates: [] }); // throws\n   *\n   * // Invalid: negative radius\n   * validateLocationFilter({ coordinates: [...], radius: -1 }); // throws\n   * ```\n   */\n  public static validateLocationFilter(locationFilter: LocationFilter): void {\n    const { polyline, coordinates, radius } = locationFilter;\n\n    // Check for presence (excluding null/undefined but allowing empty string for better error message)\n    const hasPolyline = polyline !== null && polyline !== undefined;\n    const hasCoordinates = coordinates !== null && coordinates !== undefined;\n\n    // At least one of polyline or coordinates must be present\n    if (!hasPolyline && !hasCoordinates) {\n      throw new FilterError('LocationFilter must have either polyline or coordinates');\n    }\n\n    // Cannot have both polyline and coordinates\n    if (hasPolyline && hasCoordinates) {\n      throw new FilterError('LocationFilter cannot have both polyline and coordinates');\n    }\n\n    // Validate polyline if present\n    if (polyline !== undefined && polyline !== null) {\n      let decodedPolyline: LatLng[];\n\n      // Type guard: Check if polyline is string, array, or invalid type\n      if (typeof polyline === 'string') {\n        // Encoded polyline string - decode it\n\n        // Check for empty or whitespace-only strings FIRST (before length check)\n        const trimmed = polyline.trim();\n        if (trimmed === '') {\n          throw new FilterError('encoded polyline string cannot be empty');\n        }\n\n        // Check max string length (DoS protection)\n        if (polyline.length > 51200) {\n          // 50 KB limit\n          throw new FilterError(\n            'encoded polyline string exceeds 50KB limit. ' + 'Use a simplified polyline or reduce precision.',\n          );\n        }\n\n        // Decode encoded polyline\n        try {\n          decodedPolyline = PolylineDecoder.decode(trimmed);\n        } catch (error: any) {\n          throw new FilterError(\n            `Invalid encoded polyline: ${error.message}. ` +\n              `Expected Google Encoded Polyline format (e.g., \"_p~iF~ps|U_ulLnnqC\"). ` +\n              `See: https://developers.google.com/maps/documentation/utilities/polylinealgorithm`,\n          );\n        }\n\n        // Replace string with decoded array for downstream processing\n        // This ensures native layers always receive coordinate arrays\n        locationFilter.polyline = decodedPolyline;\n      } else if (Array.isArray(polyline)) {\n        // Already a coordinate array - use as-is\n        decodedPolyline = polyline;\n      } else {\n        // Invalid type (not string or array)\n        throw new FilterError(\n          'polyline must be a string (encoded polyline) or array of LatLng coordinates. ' +\n            `Received: ${typeof polyline}`,\n        );\n      }\n\n      // Validate decoded polyline structure\n      if (decodedPolyline.length === 0) {\n        throw new FilterError('decoded polyline is empty');\n      }\n\n      if (decodedPolyline.length < 2) {\n        throw new FilterError('polyline must contain at least 2 coordinates to define a path');\n      }\n\n      if (decodedPolyline.length > 1000) {\n        throw new FilterError(\n          `polyline contains ${decodedPolyline.length} points, maximum is 1,000. ` +\n            `Use a simplified polyline or reduce precision.`,\n        );\n      }\n\n      // Validate each coordinate\n      for (let i = 0; i < decodedPolyline.length; i++) {\n        if (!this.isValidLatLng(decodedPolyline[i])) {\n          throw new FilterError(`polyline[${i}] is not a valid LatLng coordinate`);\n        }\n      }\n    }\n\n    // Validate coordinates if present\n    if (coordinates) {\n      if (!Array.isArray(coordinates)) {\n        throw new FilterError('coordinates must be an array');\n      }\n\n      if (coordinates.length === 0) {\n        throw new FilterError('coordinates must contain at least one coordinate');\n      }\n\n      // Prevent DoS via huge coordinates arrays (max 1000 points)\n      if (coordinates.length > 1000) {\n        throw new FilterError('coordinates must not exceed 1,000 points');\n      }\n\n      for (let i = 0; i < coordinates.length; i++) {\n        if (!this.isValidLatLng(coordinates[i])) {\n          throw new FilterError(`coordinates[${i}] is not a valid LatLng coordinate`);\n        }\n      }\n    }\n\n    // Validate radius if present\n    if (radius !== undefined) {\n      if (typeof radius !== 'number' || !isFinite(radius)) {\n        throw new FilterError('radius must be a finite number');\n      }\n\n      if (radius <= 0) {\n        throw new FilterError('radius must be greater than 0');\n      }\n\n      // Prevent unreasonably large radius (50km = 50,000 meters)\n      if (radius > 50000) {\n        throw new FilterError('radius must not exceed 50,000 meters (50km)');\n      }\n    }\n  }\n\n  /**\n   * Validate time range filter configuration.\n   *\n   * Valid time range must have:\n   * - start and end as Date objects\n   * - start must be before end\n   *\n   * @param timeRange - Time range filter to validate\n   * @throws {Error} If validation fails\n   *\n   * @example\n   * ```typescript\n   * // Valid\n   * validateTimeRangeFilter({\n   *   start: new Date('2024-01-01'),\n   *   end: new Date('2024-12-31')\n   * });\n   *\n   * // Invalid: end before start\n   * validateTimeRangeFilter({\n   *   start: new Date('2024-12-31'),\n   *   end: new Date('2024-01-01')\n   * }); // throws\n   * ```\n   */\n  public static validateTimeRangeFilter(timeRange: TimeRangeFilter): void {\n    const { start, end } = timeRange;\n\n    // Validate start\n    if (!(start instanceof Date)) {\n      throw new FilterError('timeRange.start must be a Date object');\n    }\n\n    if (isNaN(start.getTime())) {\n      throw new FilterError('timeRange.start is an invalid Date');\n    }\n\n    // Validate end\n    if (!(end instanceof Date)) {\n      throw new FilterError('timeRange.end must be a Date object');\n    }\n\n    if (isNaN(end.getTime())) {\n      throw new FilterError('timeRange.end is an invalid Date');\n    }\n\n    // Validate start < end\n    if (start >= end) {\n      throw new FilterError('timeRange.start must be before timeRange.end');\n    }\n  }\n\n  /**\n   * Validate complete filter configuration.\n   *\n   * Valid filter must have:\n   * - At least one of: location or timeRange\n   * - Valid location filter (if present)\n   * - Valid time range filter (if present)\n   *\n   * @param filter - Filter configuration to validate\n   * @throws {Error} If validation fails\n   *\n   * @example\n   * ```typescript\n   * // Valid: location only\n   * validateFilterConfig({\n   *   location: { coordinates: [{ lat: 0, lng: 0 }] }\n   * });\n   *\n   * // Valid: time only\n   * validateFilterConfig({\n   *   timeRange: { start: new Date(), end: new Date() }\n   * });\n   *\n   * // Valid: both\n   * validateFilterConfig({\n   *   location: { coordinates: [...] },\n   *   timeRange: { start: ..., end: ... }\n   * });\n   *\n   * // Invalid: neither\n   * validateFilterConfig({}); // throws\n   * ```\n   */\n  public static validateFilterConfig(filter: FilterConfig): void {\n    const { location, timeRange } = filter;\n\n    // At least one filter type must be present\n    if (!location && !timeRange) {\n      throw new FilterError('Filter must have at least one of location or timeRange');\n    }\n\n    // Validate location filter if present\n    if (location) {\n      this.validateLocationFilter(location);\n    }\n\n    // Validate time range filter if present\n    if (timeRange) {\n      this.validateTimeRangeFilter(timeRange);\n    }\n  }\n}\n"]}